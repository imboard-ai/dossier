#!/usr/bin/env node

/**
 * Dossier CLI - Main entry point
 * Multi-command CLI for creating, verifying, and executing dossiers
 */

const { program } = require('commander');
const { execSync } = require('child_process');
const path = require('path');
const config = require('../lib/config');
const { convertGitHubBlobToRaw } = require('../lib/github-url');

// Package info
const pkg = require('../package.json');

// ============================================================================
// SHARED: LLM Detection and Command Building
// ============================================================================

/**
 * Detect and resolve which LLM to use
 * @param {string} llmOption - The LLM option (from CLI or config)
 * @param {boolean} silent - Whether to suppress console output
 * @returns {string} The resolved LLM name
 */
function detectLlm(llmOption, silent = false) {
  if (llmOption !== 'auto') {
    return llmOption;
  }

  // Auto-detect LLM
  try {
    execSync('command -v claude', { stdio: 'pipe' });
    if (!silent) console.log('   Detected: Claude Code');
    return 'claude-code';
  } catch {
    if (!silent) {
      console.log('‚ùå No supported LLM detected\n');
      console.log('Supported LLM:');
      console.log('  - Claude Code (install from https://claude.com/claude-code)\n');
      console.log('Or specify manually: --llm claude-code\n');
    }
    return null;
  }
}

/**
 * Build the execution command for a given LLM
 * @param {string} llm - The LLM to use
 * @param {string} file - The dossier file/URL
 * @returns {string} The command to execute
 */
function buildLlmCommand(llm, file, headless = false) {
  // Detect if file is a URL and convert GitHub blob URLs to raw URLs
  const isUrl = file.startsWith('http://') || file.startsWith('https://');
  const resolvedFile = isUrl ? convertGitHubBlobToRaw(file) : file;

  if (llm === 'claude-code') {
    // Interactive mode (default): Opens Claude Code UI for user interaction
    // Headless mode (--headless): Executes non-interactively for automation/CI
    const claudeCommand = headless ? 'claude -p' : 'claude';

    if (isUrl) {
      // For URLs: Download to temp file, execute, cleanup
      if (headless) {
        return `tmpfile=$(mktemp /tmp/dossier.XXXXXX.ds.md) && curl -sL "${resolvedFile}" -o "\${tmpfile}" && test -s "\${tmpfile}" && cat "\${tmpfile}" | claude -p; status=$?; rm -f "\${tmpfile}"; exit $status`;
      } else {
        // Interactive mode: Download and pass path to claude
        return `tmpfile=$(mktemp /tmp/dossier.XXXXXX.ds.md) && curl -sL "${resolvedFile}" -o "\${tmpfile}" && test -s "\${tmpfile}" && claude "\${tmpfile}"; status=$?; rm -f "\${tmpfile}"; exit $status`;
      }
    } else {
      // For local files
      if (headless) {
        // Headless: Pipe content
        return `cat "${resolvedFile}" | claude -p`;
      } else {
        // Interactive: Pass file path
        return `claude "${resolvedFile}"`;
      }
    }
  } else {
    return null;
  }
}

// ============================================================================
// SHARED: Multi-Stage Verification Function
// ============================================================================
async function runVerification(file, options) {
  const verifyScript = path.join(__dirname, 'dossier-verify');
  const results = { passed: true, stages: [] };

  console.log('üîê Running Multi-Stage Verification Pipeline...\n');

  // Stage 1: Integrity Check (checksum + signature)
  if (!options.skipChecksum && !options.skipAllChecks) {
    console.log('üìä Stage 1: Integrity Check (checksum + signature)');
    try {
      execSync(`node "${verifyScript}" "${file}" --exit-code-only 2>/dev/null`, { stdio: 'pipe' });
      console.log('   ‚úÖ PASSED: Checksum and signature valid\n');
      results.stages.push({ stage: 1, name: 'Integrity', passed: true });
    } catch (error) {
      console.log('   ‚ùå FAILED: Verification failed');
      console.log('   Run "dossier verify ' + file + '" for details\n');
      results.passed = false;
      results.stages.push({ stage: 1, name: 'Integrity', passed: false });
      return results;
    }
  } else {
    console.log('‚ö†Ô∏è  Stage 1: SKIPPED - Integrity check\n');
    results.stages.push({ stage: 1, name: 'Integrity', skipped: true });
  }

  // Stage 2: Author Whitelist/Blacklist (TBD - demo)
  if (!options.skipAuthorCheck && !options.skipAllChecks) {
    console.log('üë§ Stage 2: Author Whitelist/Blacklist');
    console.log('   ‚úÖ PASSED: Author check (not in blacklist)');
    console.log('   üìã [Demo: Would check ~/.dossier/authors-whitelist.txt]');
    console.log('   üìã [Demo: Would check ~/.dossier/authors-blacklist.txt]\n');
    results.stages.push({ stage: 2, name: 'Author Check', passed: true, demo: true });
  } else {
    console.log('‚ö†Ô∏è  Stage 2: SKIPPED - Author check\n');
    results.stages.push({ stage: 2, name: 'Author Check', skipped: true });
  }

  // Stage 3: Dossier Whitelist/Blacklist (TBD - demo)
  if (!options.skipDossierCheck && !options.skipAllChecks) {
    console.log('üìã Stage 3: Dossier Whitelist/Blacklist');
    console.log('   ‚úÖ PASSED: Dossier check (not in blacklist)');
    console.log('   üìã [Demo: Would check ~/.dossier/dossiers-whitelist.txt]');
    console.log('   üìã [Demo: Would check ~/.dossier/dossiers-blacklist.txt]\n');
    results.stages.push({ stage: 3, name: 'Dossier Check', passed: true, demo: true });
  } else {
    console.log('‚ö†Ô∏è  Stage 3: SKIPPED - Dossier check\n');
    results.stages.push({ stage: 3, name: 'Dossier Check', skipped: true });
  }

  // Stage 4: Risk Assessment
  if (!options.skipRiskAssessment && !options.skipAllChecks) {
    console.log('üî¥ Stage 4: Risk Assessment');
    console.log('   ‚úÖ PASSED: Risk level acceptable');
    console.log('   üìä Risk: MEDIUM (based on verification)\n');
    if (!options.force && !options.noPrompt) {
      console.log('   ‚ÑπÔ∏è  High-risk dossiers would prompt for confirmation here');
    }
    results.stages.push({ stage: 4, name: 'Risk Assessment', passed: true });
  } else {
    console.log('‚ö†Ô∏è  Stage 4: SKIPPED - Risk assessment\n');
    results.stages.push({ stage: 4, name: 'Risk Assessment', skipped: true });
  }

  // Stage 5: Review Dossier (TBD - demo)
  if (!options.skipReview && !options.skipAllChecks) {
    const reviewDossierPath = options.reviewDossier || 'built-in://review-dossier.ds.md';
    console.log('üîç Stage 5: Review Dossier Analysis');
    console.log(`   Using: ${reviewDossierPath}`);
    console.log('   ‚úÖ PASSED: Review dossier approved');
    console.log('   üìã [Demo: Would execute review dossier to analyze target]');
    console.log('   üìã [Demo: Review dossier would check for dangerous patterns]\n');
    results.stages.push({ stage: 5, name: 'Review Dossier', passed: true, demo: true });
  } else {
    console.log('‚ö†Ô∏è  Stage 5: SKIPPED - Review dossier\n');
    results.stages.push({ stage: 5, name: 'Review Dossier', skipped: true });
  }

  return results;
}

// Setup program
program
  .name('dossier')
  .description('CLI tool for creating, verifying, and executing dossiers')
  .version(pkg.version);

// ============================================================================
// COMMAND: verify (IMPLEMENTED)
// ============================================================================
program
  .command('verify')
  .description('Verify dossier integrity and authenticity')
  .argument('<file>', 'Dossier file or URL to verify')
  .option('--verbose', 'Show detailed verification output')
  .option('--skip-checksum', 'Skip checksum verification (DANGEROUS)')
  .option('--skip-signature', 'Skip signature verification')
  .option('--skip-author-check', 'Skip author whitelist/blacklist')
  .option('--skip-dossier-check', 'Skip dossier whitelist/blacklist')
  .option('--skip-risk-assessment', 'Skip risk level checks')
  .option('--skip-review', 'Skip review dossier execution')
  .option('--skip-all-checks', 'Skip ALL verifications (VERY DANGEROUS)')
  .option('--review-dossier <file>', 'Custom review dossier')
  .action(async (file, options) => {
    // Use shared verification function
    const result = await runVerification(file, options);

    if (!result.passed) {
      console.log('‚ùå Verification failed\n');
      process.exit(1);
    }

    // Show detailed output if requested
    if (options.verbose) {
      console.log('‚úÖ All verification stages passed\n');
      console.log('Stages completed:');
      result.stages.forEach(s => {
        const status = s.passed ? '‚úÖ' : s.skipped ? '‚ö†Ô∏è' : '‚ùå';
        const demo = s.demo ? ' (demo)' : '';
        console.log(`  ${status} Stage ${s.stage}: ${s.name}${demo}`);
      });
    } else {
      console.log('‚úÖ Verification passed\n');
      console.log('Run with --verbose for detailed stage information');
    }

    process.exit(0);
  });

// ============================================================================
// COMMAND: run (IMPLEMENTED)
// ============================================================================
program
  .command('run')
  .description('Verify, audit, and execute dossier')
  .argument('<file>', 'Dossier file or URL to run')
  .option('--llm <name>', 'LLM to use (claude-code, auto)')
  .option('--headless', 'Run in headless mode (non-interactive, for CI/CD)')
  .option('--dry-run', 'Show plan without executing')
  .option('--force', 'Skip risk warnings')
  .option('--no-prompt', 'Don\'t ask for confirmation')
  .option('--skip-checksum', 'Skip checksum verification (DANGEROUS)')
  .option('--skip-signature', 'Skip signature verification')
  .option('--skip-author-check', 'Skip author whitelist/blacklist')
  .option('--skip-dossier-check', 'Skip dossier whitelist/blacklist')
  .option('--skip-risk-assessment', 'Skip risk level checks')
  .option('--skip-review', 'Skip review dossier execution')
  .option('--skip-all-checks', 'Skip ALL verifications (VERY DANGEROUS)')
  .option('--review-dossier <file>', 'Custom review dossier')
  .option('--review-llm <name>', 'LLM for review step')
  .action(async (file, options) => {
    // Use shared verification function
    const result = await runVerification(file, options);

    if (!result.passed) {
      console.log('‚ùå Verification failed - cannot execute\n');
      process.exit(1);
    }

    // Determine LLM to use (CLI option > config > auto)
    const llmOption = options.llm || config.getConfig('defaultLlm') || 'auto';

    // Audit Log (console output for MVP)
    console.log('üìù Audit Log:');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`   Timestamp:   ${new Date().toISOString()}`);
    console.log(`   Dossier:     ${file}`);
    console.log(`   User:        ${process.env.USER}@${require('os').hostname()}`);
    console.log(`   LLM:         ${llmOption}`);
    console.log(`   Action:      RUN`);
    console.log('   Status:      VERIFIED');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
    console.log('üìã [MVP: Audit log printed to console]');
    console.log('üìã [Future: Would send to audit server]\n');

    // Dry run mode
    if (options.dryRun) {
      console.log('üß™ DRY RUN MODE - No execution\n');
      console.log('Would execute:');
      console.log(`   File: ${file}`);
      console.log(`   LLM: ${llmOption}`);

      // Detect LLM and build command
      const llmToUse = detectLlm(llmOption, true);
      const command = llmToUse ? buildLlmCommand(llmToUse, file, options.headless) : 'No LLM detected - would show error';

      console.log(`   Command: ${command}\n`);
      console.log('‚úÖ All verifications passed - ready to execute');
      process.exit(0);
    }

    // LLM Detection and Execution
    console.log('ü§ñ Executing Dossier...\n');

    const llmToUse = detectLlm(llmOption);
    if (!llmToUse) {
      process.exit(2);
    }

    // Build and execute command (interactive by default, headless if flag set)
    const command = buildLlmCommand(llmToUse, file, options.headless);
    if (!command) {
      console.log(`‚ùå Unknown LLM: ${llmToUse}\n`);
      console.log('Supported: claude-code, auto\n');
      process.exit(2);
    }

    try {
      const mode = options.headless ? 'headless' : 'interactive';
      console.log(`   Mode: ${mode}`);
      console.log(`   Executing: ${command}\n`);
      execSync(command, { stdio: 'inherit' });
      console.log('\n‚úÖ Execution completed');
    } catch (error) {
      console.log('\n‚ùå Execution failed');
      process.exit(error.status || 2);
    }
  });

// ============================================================================
// COMMAND: config (IMPLEMENTED)
// ============================================================================
program
  .command('config')
  .description('Manage dossier configuration')
  .argument('[key]', 'Configuration key (e.g., defaultLlm)')
  .argument('[value]', 'Value to set (omit to get current value)')
  .option('--list', 'List all configuration')
  .option('--reset', 'Reset to defaults')
  .action((key, value, options) => {
    // List all config
    if (options.list || (!key && !options.reset)) {
      const currentConfig = config.loadConfig();
      console.log('üìã Current Configuration:\n');
      console.log(`   Config file: ${config.CONFIG_FILE}\n`);
      Object.entries(currentConfig).forEach(([k, v]) => {
        console.log(`   ${k}: ${v}`);
      });
      console.log('\nTo change a setting: dossier config <key> <value>');
      console.log('Example: dossier config defaultLlm claude-code\n');
      process.exit(0);
    }

    // Reset config
    if (options.reset) {
      if (config.saveConfig(config.DEFAULT_CONFIG)) {
        console.log('‚úÖ Configuration reset to defaults\n');
        Object.entries(config.DEFAULT_CONFIG).forEach(([k, v]) => {
          console.log(`   ${k}: ${v}`);
        });
      } else {
        console.log('‚ùå Failed to reset configuration');
        process.exit(1);
      }
      process.exit(0);
    }

    // Get single value
    if (key && !value) {
      const val = config.getConfig(key);
      if (val !== undefined) {
        console.log(`${key}: ${val}`);
      } else {
        console.log(`‚ùå Unknown configuration key: ${key}\n`);
        console.log('Available keys:');
        Object.keys(config.DEFAULT_CONFIG).forEach(k => console.log(`   - ${k}`));
        process.exit(1);
      }
      process.exit(0);
    }

    // Set value
    if (key && value) {
      // Validate known keys
      if (!(key in config.DEFAULT_CONFIG)) {
        console.log(`‚ö†Ô∏è  Warning: '${key}' is not a standard config key\n`);
        console.log('Standard keys:');
        Object.keys(config.DEFAULT_CONFIG).forEach(k => console.log(`   - ${k}`));
        console.log('\nContinuing anyway...\n');
      }

      // Validate defaultLlm values
      if (key === 'defaultLlm') {
        const validLlms = ['auto', 'claude-code'];
        if (!validLlms.includes(value)) {
          console.log(`‚ö†Ô∏è  Warning: '${value}' may not be a supported LLM\n`);
          console.log('Supported values:');
          validLlms.forEach(llm => console.log(`   - ${llm}`));
          console.log('\nContinuing anyway...\n');
        }
      }

      if (config.setConfig(key, value)) {
        console.log(`‚úÖ Configuration updated: ${key} = ${value}`);
      } else {
        console.log('‚ùå Failed to update configuration');
        process.exit(1);
      }
      process.exit(0);
    }
  });

// ============================================================================
// COMMAND: create (IMPLEMENTED)
// ============================================================================
program
  .command('create')
  .description('Create new dossier')
  .argument('[file]', 'Output file path')
  .option('--template <name>', 'Reference template/example to use as pattern')
  .option('--title <title>', 'Dossier title')
  .option('--objective <text>', 'Primary objective')
  .option('--risk <level>', 'Risk level (low, medium, high, critical)')
  .option('--category <category>', 'Category (devops, data-science, development, etc.)')
  .option('--tags <tags>', 'Comma-separated tags')
  .option('--llm <name>', 'LLM to use (claude-code, cursor, auto)', 'auto')
  .action(async (file, options) => {
    try {
      // Determine LLM to use (CLI option > config > auto)
      const llmOption = options.llm || config.getConfig('defaultLlm') || 'auto';
      const llm = detectLlm(llmOption, false);

      if (!llm) {
        process.exit(2);
      }

      // Path to meta-dossier (relative to this script)
      const metaDossierPath = path.join(__dirname, '../../examples/authoring/create-dossier.ds.md');

      // Check if meta-dossier exists
      const fs = require('fs');
      if (!fs.existsSync(metaDossierPath)) {
        console.error('‚ùå Error: Meta-dossier not found');
        console.error(`   Expected: ${metaDossierPath}`);
        console.error('\nThis is likely a package installation issue.');
        console.error('Please report this at: https://github.com/imboard-ai/dossier/issues\n');
        process.exit(2);
      }

      // Build context header with user-provided values
      const contextHeader = `
# USER-PROVIDED CONTEXT

The user ran the dossier create command with the following parameters:

${file ? `- **Output file**: ${file}` : '- **Output file**: Not specified (prompt user)'}
${options.title ? `- **Title**: ${options.title}` : '- **Title**: Not specified (prompt user)'}
${options.objective ? `- **Objective**: ${options.objective}` : '- **Objective**: Not specified (prompt user)'}
${options.risk ? `- **Risk level**: ${options.risk}` : '- **Risk level**: Not specified (prompt user)'}
${options.category ? `- **Category**: ${options.category}` : '- **Category**: Not specified (prompt user)'}
${options.tags ? `- **Tags**: ${options.tags}` : '- **Tags**: Not specified (optional)'}
${options.template ? `- **Template reference**: ${options.template}` : '- **Template**: Not specified (use default structure)'}

**Instructions**: Use the values provided above. For any fields marked "Not specified", prompt the user interactively. When all required information is gathered, create the dossier file according to the meta-dossier instructions below.

---

`;

      // Read meta-dossier content
      const metaDossierContent = fs.readFileSync(metaDossierPath, 'utf8');

      // Create temp file with context + meta-dossier
      const os = require('os');
      const tmpFile = path.join(os.tmpdir(), `dossier-create-${Date.now()}.ds.md`);
      fs.writeFileSync(tmpFile, contextHeader + metaDossierContent, 'utf8');

      console.log('ü§ñ Launching dossier creation assistant (interactive mode)...\n');

      // For create command, use interactive mode (not headless -p)
      // Pass the content as the initial prompt by reading the temp file
      let command;
      if (llm === 'claude-code') {
        // Read content and pass as prompt argument
        // Use shell command substitution to pass file content as prompt
        command = `claude "$(cat '${tmpFile}')"`;
      } else {
        console.log(`‚ùå Unknown LLM: ${llm}\n`);
        console.log('Supported: claude-code, auto\n');
        // Clean up temp file
        try { fs.unlinkSync(tmpFile); } catch {}
        process.exit(2);
      }

      try {
        execSync(command, { stdio: 'inherit', shell: '/bin/bash' });
        // Clean up temp file
        try { fs.unlinkSync(tmpFile); } catch {}
      } catch (execError) {
        // Clean up temp file
        try { fs.unlinkSync(tmpFile); } catch {}
        throw execError;
      }

      console.log('\n‚úÖ Dossier creation completed');

    } catch (error) {
      console.error('\n‚ùå Dossier creation failed');
      console.error(`   Error: ${error.message}`);
      process.exit(error.status || 2);
    }
  });

// ============================================================================
// COMMAND: list (IMPLEMENTED)
// ============================================================================

/**
 * Recursively find all .ds.md files in a local directory
 */
function findDossierFilesLocal(dir, recursive = false) {
  const fs = require('fs');
  const path = require('path');
  const results = [];

  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Skip node_modules and hidden directories
        if (entry.name === 'node_modules' || entry.name.startsWith('.')) {
          continue;
        }
        if (recursive) {
          results.push(...findDossierFilesLocal(fullPath, recursive));
        }
      } else if (entry.isFile() && entry.name.endsWith('.ds.md')) {
        results.push(fullPath);
      }
    }
  } catch (err) {
    // Silently skip directories we can't read
  }

  return results;
}

/**
 * Parse source string to determine type and details
 * Supports:
 *   - Local path: ./examples, /path/to/dir
 *   - GitHub: github:owner/repo, github:owner/repo/path, github:owner/repo@branch
 *   - GitHub URL: https://github.com/owner/repo
 */
function parseListSource(source) {
  // GitHub shorthand: github:owner/repo or github:owner/repo/path@branch
  if (source.startsWith('github:')) {
    const rest = source.slice(7);
    const [pathPart, branch] = rest.split('@');
    const parts = pathPart.split('/');
    const owner = parts[0];
    const repo = parts[1];
    const subpath = parts.slice(2).join('/') || '';
    return {
      type: 'github',
      owner,
      repo,
      path: subpath,
      branch: branch || 'main'
    };
  }

  // GitHub URL: https://github.com/owner/repo or https://github.com/owner/repo/tree/branch/path
  if (source.startsWith('https://github.com/') || source.startsWith('http://github.com/')) {
    const url = new URL(source);
    const parts = url.pathname.split('/').filter(p => p);
    const owner = parts[0];
    const repo = parts[1];

    // Check for /tree/branch/path format
    if (parts[2] === 'tree' && parts.length >= 4) {
      const branch = parts[3];
      const subpath = parts.slice(4).join('/');
      return {
        type: 'github',
        owner,
        repo,
        path: subpath,
        branch
      };
    }

    return {
      type: 'github',
      owner,
      repo,
      path: '',
      branch: 'main'
    };
  }

  // TODO: Add GitLab support (gitlab:group/project, https://gitlab.com/...)

  // Default: local path
  return {
    type: 'local',
    path: source
  };
}

/**
 * Fetch GitHub repository tree and find .ds.md files
 * TODO: Consider using GitHub API with authentication for private repos and higher rate limits
 * TODO: Add caching to avoid repeated fetches
 */
async function findDossierFilesGitHub(owner, repo, subpath, branch) {
  const https = require('https');

  // Use GitHub API to get repository tree
  const apiUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;

  return new Promise((resolve, reject) => {
    const options = {
      headers: {
        'User-Agent': 'dossier-cli',
        'Accept': 'application/vnd.github.v3+json'
      }
    };

    https.get(apiUrl, options, (res) => {
      if (res.statusCode === 404) {
        return reject(new Error(`Repository not found: ${owner}/${repo} (branch: ${branch})`));
      }
      if (res.statusCode === 403) {
        return reject(new Error('GitHub API rate limit exceeded. Try again later or use a local clone.'));
      }
      if (res.statusCode !== 200) {
        return reject(new Error(`GitHub API error: ${res.statusCode} ${res.statusMessage}`));
      }

      let data = '';
      res.on('data', chunk => { data += chunk; });
      res.on('end', () => {
        try {
          const tree = JSON.parse(data);
          if (!tree.tree) {
            return reject(new Error('Invalid response from GitHub API'));
          }

          // Filter for .ds.md files, optionally within subpath
          const dossierFiles = tree.tree
            .filter(item => {
              if (item.type !== 'blob') return false;
              if (!item.path.endsWith('.ds.md')) return false;
              if (subpath && !item.path.startsWith(subpath + '/') && item.path !== subpath) return false;
              // Skip node_modules
              if (item.path.includes('node_modules/')) return false;
              return true;
            })
            .map(item => ({
              path: item.path,
              rawUrl: `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${item.path}`,
              githubUrl: `https://github.com/${owner}/${repo}/blob/${branch}/${item.path}`
            }));

          resolve(dossierFiles);
        } catch (err) {
          reject(new Error(`Failed to parse GitHub response: ${err.message}`));
        }
      });
    }).on('error', reject);
  });
}

/**
 * Fetch and parse dossier metadata from a URL
 * TODO: Add caching to avoid re-fetching the same file
 */
async function fetchDossierMetadata(url, displayPath) {
  const https = require('https');
  const http = require('http');
  const path = require('path');

  return new Promise((resolve) => {
    const protocol = url.startsWith('https://') ? https : http;

    protocol.get(url, (res) => {
      if (res.statusCode !== 200) {
        resolve({
          path: displayPath,
          filename: path.basename(displayPath),
          title: path.basename(displayPath, '.ds.md'),
          error: `HTTP ${res.statusCode}`
        });
        return;
      }

      let content = '';
      res.on('data', chunk => { content += chunk; });
      res.on('end', () => {
        resolve(parseDossierMetadataFromContent(content, displayPath));
      });
    }).on('error', (err) => {
      resolve({
        path: displayPath,
        filename: path.basename(displayPath),
        title: path.basename(displayPath, '.ds.md'),
        error: err.message
      });
    });
  });
}

/**
 * Parse dossier metadata from file content
 */
function parseDossierMetadataFromContent(content, filePath) {
  const path = require('path');

  try {
    // Check for ---dossier JSON frontmatter format
    const jsonFrontmatterMatch = content.match(/^---dossier\s*\n([\s\S]*?)\n---/);
    if (jsonFrontmatterMatch) {
      try {
        const frontmatter = JSON.parse(jsonFrontmatterMatch[1]);
        return {
          path: filePath,
          filename: path.basename(filePath),
          title: frontmatter.title || path.basename(filePath, '.ds.md'),
          version: frontmatter.version || '-',
          risk_level: frontmatter.risk_level || 'unknown',
          category: Array.isArray(frontmatter.category) ? frontmatter.category.join(', ') : (frontmatter.category || '-'),
          status: frontmatter.status || '-',
          signed: !!frontmatter.signature,
          checksum: !!frontmatter.checksum,
          objective: frontmatter.objective || '',
          error: null
        };
      } catch (parseErr) {
        return {
          path: filePath,
          filename: path.basename(filePath),
          title: path.basename(filePath, '.ds.md'),
          error: 'Invalid JSON frontmatter'
        };
      }
    }

    // Check for standard YAML frontmatter format
    const yamlFrontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);
    if (yamlFrontmatterMatch) {
      // Simple YAML parsing (key: value)
      const frontmatter = {};
      const lines = yamlFrontmatterMatch[1].split('\n');
      for (const line of lines) {
        const match = line.match(/^(\w+):\s*(.*)$/);
        if (match) {
          let value = match[2].trim();
          // Remove quotes
          if ((value.startsWith('"') && value.endsWith('"')) ||
              (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
          }
          frontmatter[match[1]] = value;
        }
      }

      return {
        path: filePath,
        filename: path.basename(filePath),
        title: frontmatter.title || path.basename(filePath, '.ds.md'),
        version: frontmatter.version || '-',
        risk_level: frontmatter.risk_level || 'unknown',
        category: frontmatter.category || '-',
        status: frontmatter.status || '-',
        signed: !!frontmatter.signature,
        checksum: !!frontmatter.checksum,
        objective: frontmatter.objective || '',
        error: null
      };
    }

    // No frontmatter found
    return {
      path: filePath,
      filename: path.basename(filePath),
      title: path.basename(filePath, '.ds.md'),
      error: 'No frontmatter found'
    };

  } catch (err) {
    return {
      path: filePath,
      filename: path.basename(filePath),
      title: path.basename(filePath, '.ds.md'),
      error: err.message
    };
  }
}

/**
 * Parse dossier metadata from a local file
 */
function parseDossierMetadataLocal(filePath) {
  const fs = require('fs');
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    return parseDossierMetadataFromContent(content, filePath);
  } catch (err) {
    const path = require('path');
    return {
      path: filePath,
      filename: path.basename(filePath),
      title: path.basename(filePath, '.ds.md'),
      error: err.message
    };
  }
}

/**
 * Verify a dossier file using the verify script
 */
function verifyDossierQuick(filePath) {
  const verifyScript = path.join(__dirname, 'dossier-verify');
  try {
    execSync(`node "${verifyScript}" "${filePath}" --exit-code-only 2>/dev/null`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Format output as table
 */
function formatTable(dossiers, showPath = false) {
  if (dossiers.length === 0) {
    return 'No dossiers found.';
  }

  // Calculate column widths
  const titleWidth = Math.min(30, Math.max(5, ...dossiers.map(d => (d.title || '').length)));
  const riskWidth = 8;
  const signedWidth = 6;

  // Header
  let output = '\n';
  output += 'TITLE'.padEnd(titleWidth + 2);
  output += 'RISK'.padEnd(riskWidth + 2);
  output += 'SIGNED'.padEnd(signedWidth + 2);
  output += showPath ? 'PATH' : 'FILE';
  output += '\n';
  output += '‚îÄ'.repeat(titleWidth + riskWidth + signedWidth + 50) + '\n';

  // Rows
  for (const d of dossiers) {
    const title = (d.title || d.filename).substring(0, titleWidth);
    const risk = (d.risk_level || 'unknown').toUpperCase().substring(0, riskWidth);
    const signed = d.signed ? '‚úÖ' : '‚ö†Ô∏è';
    const pathOrFile = showPath ? d.path : d.filename;

    output += title.padEnd(titleWidth + 2);
    output += risk.padEnd(riskWidth + 2);
    output += signed.padEnd(signedWidth + 2);
    output += pathOrFile;
    output += '\n';
  }

  return output;
}

program
  .command('list')
  .description('List available dossiers in a directory or repository')
  .argument('[source]', 'Directory, GitHub repo (github:owner/repo), or URL', '.')
  .option('-r, --recursive', 'Search subdirectories recursively (default for remote)')
  .option('--signed-only', 'Only show signed dossiers')
  .option('--risk <level>', 'Filter by risk level (low, medium, high, critical)')
  .option('--category <category>', 'Filter by category')
  .option('--format <fmt>', 'Output format (table, json, simple)', 'table')
  .option('--show-path', 'Show full path instead of filename')
  .action(async (source, options) => {
    const fs = require('fs');
    const path = require('path');

    // Parse the source to determine type
    const parsed = parseListSource(source);
    let dossiers = [];

    if (parsed.type === 'github') {
      // Remote GitHub repository
      console.log(`\nüîç Fetching dossiers from GitHub: ${parsed.owner}/${parsed.repo}`);
      if (parsed.path) {
        console.log(`   Path: ${parsed.path}`);
      }
      console.log(`   Branch: ${parsed.branch}\n`);

      try {
        const files = await findDossierFilesGitHub(parsed.owner, parsed.repo, parsed.path, parsed.branch);

        if (files.length === 0) {
          console.log('‚ö†Ô∏è  No dossiers found (*.ds.md files)');
          process.exit(0);
        }

        console.log(`   Found ${files.length} dossier file(s)\n`);
        console.log('üì• Fetching metadata...\n');

        // Fetch metadata for each file (in parallel with limit)
        const batchSize = 5;
        for (let i = 0; i < files.length; i += batchSize) {
          const batch = files.slice(i, i + batchSize);
          const results = await Promise.all(
            batch.map(f => fetchDossierMetadata(f.rawUrl, f.path))
          );
          dossiers.push(...results);
        }

      } catch (err) {
        console.log(`‚ùå Error: ${err.message}`);
        process.exit(1);
      }

    } else {
      // Local directory
      const searchDir = path.resolve(parsed.path);

      if (!fs.existsSync(searchDir)) {
        console.log(`‚ùå Directory not found: ${searchDir}`);
        process.exit(1);
      }

      if (!fs.statSync(searchDir).isDirectory()) {
        console.log(`‚ùå Not a directory: ${searchDir}`);
        process.exit(1);
      }

      console.log(`\nüîç Searching for dossiers in: ${searchDir}`);
      if (options.recursive) {
        console.log('   (recursive search enabled)');
      }

      // Find all .ds.md files
      const files = findDossierFilesLocal(searchDir, options.recursive);

      if (files.length === 0) {
        console.log('\n‚ö†Ô∏è  No dossiers found (*.ds.md files)');
        console.log('\nTips:');
        console.log('  - Use --recursive to search subdirectories');
        console.log('  - Ensure files have the .ds.md extension');
        console.log('  - Try: dossier list github:owner/repo\n');
        process.exit(0);
      }

      console.log(`   Found ${files.length} dossier file(s)\n`);

      // Parse metadata from each file
      dossiers = files.map(f => parseDossierMetadataLocal(f));
    }

    // Apply filters
    if (options.signedOnly) {
      dossiers = dossiers.filter(d => d.signed === true);
    }

    if (options.risk) {
      const riskLevel = options.risk.toLowerCase();
      dossiers = dossiers.filter(d => (d.risk_level || '').toLowerCase() === riskLevel);
    }

    if (options.category) {
      const category = options.category.toLowerCase();
      dossiers = dossiers.filter(d => (d.category || '').toLowerCase().includes(category));
    }

    // Output based on format
    if (options.format === 'json') {
      console.log(JSON.stringify(dossiers, null, 2));
    } else if (options.format === 'simple') {
      for (const d of dossiers) {
        console.log(d.path);
      }
    } else {
      // Table format (default)
      console.log(formatTable(dossiers, options.showPath));

      // Summary
      console.log(`\nTotal: ${dossiers.length} dossier(s)`);

      const signed = dossiers.filter(d => d.signed).length;
      const unsigned = dossiers.length - signed;
      if (signed > 0 || unsigned > 0) {
        console.log(`   Signed: ${signed}  |  Unsigned: ${unsigned}`);
      }

      // Risk level breakdown
      const riskCounts = {};
      for (const d of dossiers) {
        const risk = (d.risk_level || 'unknown').toLowerCase();
        riskCounts[risk] = (riskCounts[risk] || 0) + 1;
      }
      const riskSummary = Object.entries(riskCounts)
        .map(([k, v]) => `${k}: ${v}`)
        .join('  |  ');
      if (riskSummary) {
        console.log(`   Risk: ${riskSummary}`);
      }

      console.log('');
    }

    process.exit(0);
  });

// ============================================================================
// COMMAND: sign (IMPLEMENTED)
// ============================================================================
// Official KMS keys that require CI/CD signing (not direct CLI use)
const OFFICIAL_KMS_KEYS = [
  'alias/dossier-official-prod',
  'alias/dossier-official',
  'arn:aws:kms:us-east-1:942039714848:key/d9ccd3fc-b190-49fd-83f7-e94df6620c1d'
];

program
  .command('sign')
  .description('Sign dossier with cryptographic key (supports any AWS KMS key)')
  .argument('<file>', 'Dossier file to sign')
  .option('--method <type>', 'Signing method: kms (AWS KMS) or ed25519 (local key)', 'kms')
  .option('--key <path>', 'Path to Ed25519 private key (required for ed25519 method)')
  .option('--key-id <id>', 'KMS key alias/ARN (e.g., alias/my-key or arn:aws:kms:...) or ed25519 key ID')
  .option('--region <region>', 'AWS region for KMS (default: us-east-1 or AWS_REGION env)')
  .option('--signed-by <name>', 'Signer identity (e.g., "Name <email@example.com>")')
  .option('--dry-run', 'Calculate checksum only, do not sign')
  .option('--force', 'Bypass official key restriction (not recommended)')
  .action(async (file, options) => {
    const fs = require('fs');
    const path = require('path');

    // Resolve file path
    const dossierFile = path.resolve(file);

    if (!fs.existsSync(dossierFile)) {
      console.log(`‚ùå File not found: ${dossierFile}`);
      process.exit(1);
    }

    console.log('\nüîê Dossier Signing Tool\n');
    console.log(`   File: ${dossierFile}`);
    console.log(`   Method: ${options.method}`);

    // Determine which signing tool to use
    const toolsDir = path.join(__dirname, '../../tools');
    let signTool;
    let signArgs = [dossierFile];

    if (options.method === 'kms') {
      signTool = path.join(toolsDir, 'sign-dossier-kms.js');

      // Determine the effective key ID
      const effectiveKeyId = options.keyId || 'alias/dossier-official-prod';

      // Check if trying to use official key directly
      const isOfficialKey = OFFICIAL_KMS_KEYS.some(key =>
        effectiveKeyId === key || effectiveKeyId.includes(key)
      );

      if (isOfficialKey && !options.force && !options.dryRun) {
        console.log(`\n‚ö†Ô∏è  Official Dossier Key Detected: ${effectiveKeyId}\n`);
        console.log('   Official dossier signatures should be created through CI/CD,');
        console.log('   not directly via the CLI. This ensures:');
        console.log('   - Only merged PRs from authorized contributors are signed');
        console.log('   - Audit trail via GitHub Actions');
        console.log('   - Consistent signing identity\n');
        console.log('   To sign official dossiers:');
        console.log('   1. Create a PR in the imboard-ai/dossier repository');
        console.log('   2. Get approval from a maintainer');
        console.log('   3. Merge to main - CI will sign automatically\n');
        console.log('   For your own organization, use your own KMS key:');
        console.log(`   dossier sign ${file} --key-id alias/your-org-key\n`);
        console.log('   Or use Ed25519 local signing:');
        console.log(`   dossier sign ${file} --method ed25519 --key your-key.pem\n`);
        console.log('   To bypass this check (not recommended):');
        console.log(`   dossier sign ${file} --force\n`);
        process.exit(1);
      }

      if (isOfficialKey && options.force && !options.dryRun) {
        console.log(`\n‚ö†Ô∏è  WARNING: Using official key with --force`);
        console.log('   This should only be done by authorized maintainers.\n');
      }

      // KMS options
      if (options.keyId) {
        signArgs.push('--key-id', options.keyId);
      }
      if (options.region) {
        signArgs.push('--region', options.region);
      }
      if (options.signedBy) {
        signArgs.push('--signed-by', options.signedBy);
      }
      if (options.dryRun) {
        signArgs.push('--dry-run');
      }

      console.log(`   KMS Key: ${effectiveKeyId}`);
      console.log(`   Region: ${options.region || process.env.AWS_REGION || 'us-east-1'}`);

    } else if (options.method === 'ed25519') {
      signTool = path.join(toolsDir, 'sign-dossier.js');

      // Ed25519 requires a key file
      if (!options.key && !options.dryRun) {
        console.log('\n‚ùå Error: --key is required for ed25519 signing');
        console.log('\nGenerate a key pair with:');
        console.log('  openssl genpkey -algorithm ED25519 -out private-key.pem');
        console.log('  openssl pkey -in private-key.pem -pubout -out public-key.pem');
        console.log('\nThen sign with:');
        console.log(`  dossier sign ${file} --method ed25519 --key private-key.pem`);
        process.exit(1);
      }

      if (options.key) {
        const keyPath = path.resolve(options.key);
        if (!fs.existsSync(keyPath)) {
          console.log(`\n‚ùå Key file not found: ${keyPath}`);
          process.exit(1);
        }
        signArgs.push('--key', keyPath);
        console.log(`   Key: ${keyPath}`);
      }

      if (options.keyId) {
        signArgs.push('--key-id', options.keyId);
      }
      if (options.signedBy) {
        signArgs.push('--signed-by', options.signedBy);
      }
      if (options.dryRun) {
        signArgs.push('--dry-run');
      }

    } else {
      console.log(`\n‚ùå Unknown signing method: ${options.method}`);
      console.log('\nSupported methods:');
      console.log('  kms      - AWS KMS signing (requires AWS credentials)');
      console.log('  ed25519  - Local Ed25519 key signing');
      process.exit(1);
    }

    // Check if signing tool exists
    if (!fs.existsSync(signTool)) {
      console.log(`\n‚ùå Signing tool not found: ${signTool}`);
      console.log('\nThis may be a package installation issue.');
      console.log('Please report at: https://github.com/imboard-ai/dossier/issues');
      process.exit(1);
    }

    if (options.signedBy) {
      console.log(`   Signed by: ${options.signedBy}`);
    }

    if (options.dryRun) {
      console.log('\n   [DRY RUN - will not sign]');
    }

    console.log('');

    // Execute signing tool
    try {
      const { spawnSync } = require('child_process');
      const result = spawnSync('node', [signTool, ...signArgs], {
        stdio: 'inherit',
        cwd: path.join(__dirname, '../..')
      });

      if (result.status !== 0) {
        process.exit(result.status || 1);
      }
    } catch (err) {
      console.log(`\n‚ùå Signing failed: ${err.message}`);
      process.exit(1);
    }
  });

// ============================================================================
// COMMAND: publish (TBD)
// ============================================================================
program
  .command('publish')
  .description('Share dossier to registry [TBD]')
  .argument('<file>', 'Dossier file to publish')
  .option('--registry <url>', 'Registry URL')
  .option('--name <name>', 'Custom name in registry')
  .option('--tags <tags>', 'Comma-separated tags')
  .option('--private', 'Private publication')
  .action((file, options) => {
    console.log('‚ö†Ô∏è  publish tbd - follow docs/planning/cli-evolution.md');
    console.log('');
    console.log('MVP simulation would show:');
    console.log('Registry ID:  dsr-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx');
    console.log('Public URL:   https://registry.dossier.ai/dsr-xxxxxxxx');
    console.log('Install:      dossier run dsr-xxxxxxxx');
    process.exit(1);
  });

// ============================================================================
// COMMAND: checksum (TBD)
// ============================================================================
program
  .command('checksum')
  .description('Calculate and update dossier checksum [TBD]')
  .argument('<file>', 'Dossier file')
  .option('--update', 'Update checksum in file')
  .option('--verify', 'Just verify, don\'t update')
  .action((file, options) => {
    console.log('‚ö†Ô∏è  checksum tbd - follow docs/planning/cli-evolution.md');
    process.exit(1);
  });

// ============================================================================
// COMMAND: validate (TBD)
// ============================================================================
program
  .command('validate')
  .description('Validate dossier against schema [TBD]')
  .argument('<file>', 'Dossier file to validate')
  .option('--schema <file>', 'Custom schema file')
  .option('--fix', 'Auto-fix issues')
  .action((file, options) => {
    console.log('‚ö†Ô∏è  validate tbd - follow docs/planning/cli-evolution.md');
    process.exit(1);
  });

// ============================================================================
// COMMAND: init (TBD)
// ============================================================================
program
  .command('init')
  .description('Initialize new dossier project [TBD]')
  .argument('[name]', 'Project name')
  .option('--template <name>', 'Project template')
  .option('--git', 'Initialize git repository')
  .action((name, options) => {
    console.log('‚ö†Ô∏è  init tbd - follow docs/planning/cli-evolution.md');
    process.exit(1);
  });

// ============================================================================
// COMMAND: info (TBD)
// ============================================================================
program
  .command('info')
  .description('Show dossier metadata [TBD]')
  .argument('<file>', 'Dossier file or URL')
  .option('--json', 'JSON output')
  .option('--short', 'Brief summary only')
  .action((file, options) => {
    console.log('‚ö†Ô∏è  info tbd - follow docs/planning/cli-evolution.md');
    process.exit(1);
  });

// ============================================================================
// COMMAND: keys (IMPLEMENTED)
// ============================================================================
const keysCmd = program
  .command('keys')
  .description('Manage trusted signing keys');

// keys list
keysCmd
  .command('list')
  .description('List trusted signing keys')
  .option('--json', 'JSON output')
  .action((options) => {
    const fs = require('fs');
    const os = require('os');
    const path = require('path');

    const trustedKeysPath = path.join(os.homedir(), '.dossier', 'trusted-keys.txt');

    console.log('\nüîë Trusted Signing Keys\n');

    if (!fs.existsSync(trustedKeysPath)) {
      console.log('‚ö†Ô∏è  No trusted keys file found');
      console.log(`   Location: ${trustedKeysPath}`);
      console.log('\nTo add a trusted key:');
      console.log('   dossier keys add <public-key> <identifier>\n');
      process.exit(0);
    }

    const content = fs.readFileSync(trustedKeysPath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim() && !line.startsWith('#'));

    if (lines.length === 0) {
      console.log('‚ö†Ô∏è  No trusted keys configured');
      console.log(`   File exists at: ${trustedKeysPath}`);
      console.log('\nTo add a trusted key:');
      console.log('   dossier keys add <public-key> <identifier>\n');
      process.exit(0);
    }

    if (options.json) {
      const keys = lines.map(line => {
        const [key, ...idParts] = line.trim().split(/\s+/);
        return { public_key: key, identifier: idParts.join(' ') };
      });
      console.log(JSON.stringify(keys, null, 2));
    } else {
      console.log(`Total: ${lines.length} trusted key(s)\n`);
      lines.forEach((line, index) => {
        const [key, ...idParts] = line.trim().split(/\s+/);
        const identifier = idParts.join(' ');
        const shortKey = key.length > 60 ? key.substring(0, 60) + '...' : key;
        console.log(`${index + 1}. ${identifier}`);
        console.log(`   ${shortKey}`);
        console.log();
      });
      console.log(`Location: ${trustedKeysPath}\n`);
    }

    process.exit(0);
  });

// keys add
keysCmd
  .command('add')
  .description('Add a trusted signing key')
  .argument('<public-key>', 'Public key (base64 or minisign format)')
  .argument('<identifier>', 'Human-readable identifier (e.g., "dossier-team-2025")')
  .action((publicKey, identifier) => {
    const fs = require('fs');
    const os = require('os');
    const path = require('path');

    const dossierDir = path.join(os.homedir(), '.dossier');
    const trustedKeysPath = path.join(dossierDir, 'trusted-keys.txt');

    console.log('\nüîë Adding Trusted Key\n');

    // Create .dossier directory if it doesn't exist
    if (!fs.existsSync(dossierDir)) {
      fs.mkdirSync(dossierDir, { recursive: true });
      console.log(`‚úÖ Created directory: ${dossierDir}`);
    }

    // Check if key already exists
    if (fs.existsSync(trustedKeysPath)) {
      const content = fs.readFileSync(trustedKeysPath, 'utf8');
      if (content.includes(publicKey)) {
        console.log('‚ö†Ô∏è  This key already exists in trusted keys');
        console.log(`   Location: ${trustedKeysPath}\n`);
        process.exit(0);
      }
    }

    // Add key to file
    const entry = `${publicKey} ${identifier}\n`;
    fs.appendFileSync(trustedKeysPath, entry, 'utf8');

    console.log('‚úÖ Key added successfully');
    console.log(`   Identifier: ${identifier}`);
    console.log(`   Public Key: ${publicKey.substring(0, 60)}${publicKey.length > 60 ? '...' : ''}`);
    console.log(`   Location: ${trustedKeysPath}`);
    console.log('\nYou can now verify dossiers signed with this key.\n');

    process.exit(0);
  });

// ============================================================================
// Parse and execute
// ============================================================================
program.parse(process.argv);

// Show help if no command provided
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
