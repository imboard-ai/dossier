#!/usr/bin/env node

/**
 * Dossier Verification CLI
 *
 * Enforces security verification of dossier files before execution.
 * Provides command-line interface for checksum and signature validation.
 *
 * Usage:
 *   dossier-verify <file-or-url>
 *   dossier-verify --run <file-or-url>
 *   dossier-verify --verbose <file-or-url>
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const https = require('https');
const http = require('http');
const { execSync } = require('child_process');
const {
  parseDossierContent,
  verifyIntegrity,
  loadTrustedKeys,
  verifyWithMinisign,
  verifyWithKms
} = require('@dossier/core');

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function error(message) {
  log(`‚ùå ${message}`, 'red');
}

function success(message) {
  log(`‚úÖ ${message}`, 'green');
}

function warning(message) {
  log(`‚ö†Ô∏è  ${message}`, 'yellow');
}

function info(message) {
  log(`‚ÑπÔ∏è  ${message}`, 'cyan');
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    verbose: false,
    run: false,
    outputPath: false,
    help: false,
    input: null,
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--verbose' || arg === '-v') {
      options.verbose = true;
    } else if (arg === '--run') {
      options.run = true;
    } else if (arg === '--output-path') {
      options.outputPath = true;
    } else if (arg === '--help' || arg === '-h') {
      options.help = true;
    } else if (!options.input) {
      options.input = arg;
    }
  }

  return options;
}

function showHelp() {
  console.log(`
${colors.bright}Dossier Verification CLI${colors.reset}

${colors.bright}Usage:${colors.reset}
  dossier-verify <file-or-url>              Verify dossier security
  dossier-verify --run <file-or-url>        Verify and execute if safe
  dossier-verify --verbose <file-or-url>    Show detailed verification
  dossier-verify --output-path <url>        Download and output path
  dossier-verify --help                     Show this help

${colors.bright}Exit Codes:${colors.reset}
  0 - Verification passed (safe to execute)
  1 - Verification failed (do not execute)
  2 - Error occurred (cannot verify)

${colors.bright}Examples:${colors.reset}
  # Verify local file
  dossier-verify path/to/dossier.ds.md

  # Verify remote dossier
  dossier-verify https://example.com/dossier.ds.md

  # Verify and run if safe
  dossier-verify --run https://example.com/dossier.ds.md

  # Use in shell script
  if dossier-verify "$URL"; then
    claude-code "run $URL"
  else
    echo "Security verification failed"
  fi

${colors.bright}Security Checks:${colors.reset}
  ‚úì SHA256 checksum verification (required)
  ‚úì Signature verification (if present)
  ‚úì Trusted keys check
  ‚úì Risk level assessment

${colors.bright}More Information:${colors.reset}
  Documentation: https://github.com/imboard-ai/dossier
  Security: SECURITY_STATUS.md
  Protocol: PROTOCOL.md
`);
}

// Download file from URL
async function downloadFile(url) {
  return new Promise((resolve, reject) => {
    const protocol = url.startsWith('https://') ? https : http;

    protocol.get(url, (res) => {
      if (res.statusCode === 301 || res.statusCode === 302) {
        // Follow redirect
        return downloadFile(res.headers.location).then(resolve).catch(reject);
      }

      if (res.statusCode !== 200) {
        return reject(new Error(`HTTP ${res.statusCode}: ${res.statusMessage}`));
      }

      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => resolve(data));
    }).on('error', reject);
  });
}

// Parse dossier frontmatter (using @dossier/core)
function parseDossier(content) {
  const parsed = parseDossierContent(content);
  return {
    frontmatter: parsed.frontmatter,
    body: parsed.body
  };
}

// Verify checksum (using @dossier/core)
function verifyChecksum(body, declaredHash) {
  const result = verifyIntegrity(body, declaredHash);
  return {
    passed: result.status === 'valid',
    declared: result.expectedHash,
    actual: result.actualHash,
  };
}

// Verify signature (using @dossier/core for real cryptographic verification)
async function verifySignature(body, frontmatter) {
  if (!frontmatter.signature) {
    return {
      present: false,
      verified: false,
      trusted: false,
      message: 'No signature present',
    };
  }

  const signature = frontmatter.signature;
  const trustedKeys = loadTrustedKeys();
  const isTrusted = trustedKeys.has(signature.public_key || signature.key_id);

  try {
    let isValid = false;

    // Verify based on algorithm
    if (signature.algorithm === 'ECDSA-SHA-256') {
      isValid = await verifyWithKms(body, signature.signature, signature.key_id);
    } else {
      // Default to Minisign (Ed25519)
      isValid = verifyWithMinisign(body, signature.signature, signature.public_key);
    }

    if (!isValid) {
      return {
        present: true,
        verified: false,
        trusted: isTrusted,
        message: 'Signature verification FAILED',
      };
    }

    return {
      present: true,
      verified: true,
      trusted: isTrusted,
      message: isTrusted
        ? `Verified signature from trusted source: ${trustedKeys.get(signature.public_key || signature.key_id)}`
        : 'Valid signature but key is not in trusted list',
    };
  } catch (err) {
    return {
      present: true,
      verified: false,
      trusted: false,
      message: `Verification error: ${err.message}`,
    };
  }
}

// Assess risk
function assessRisk(frontmatter, checksumResult, signatureResult) {
  const issues = [];
  let riskLevel = 'low';

  // Checksum failure is critical
  if (!checksumResult.passed) {
    issues.push('Checksum verification FAILED - content has been tampered with');
    riskLevel = 'critical';
  }

  // Signature issues
  if (signatureResult.present && !signatureResult.verified) {
    issues.push('Signature verification FAILED or could not be verified');
    if (riskLevel !== 'critical') riskLevel = 'high';
  }

  // No signature on high-risk dossier
  if (!signatureResult.present && frontmatter.risk_level === 'high') {
    issues.push('High-risk dossier without signature');
    if (riskLevel === 'low') riskLevel = 'medium';
  }

  if (!signatureResult.present && frontmatter.risk_level === 'critical') {
    issues.push('Critical-risk dossier without signature');
    if (riskLevel !== 'critical') riskLevel = 'high';
  }

  return {
    level: riskLevel,
    issues,
    recommendation: checksumResult.passed ? 'ALLOW' : 'BLOCK',
  };
}

// Main verification function
async function verifyDossier(input, options) {
  try {
    log(`\n${colors.bright}üîê Dossier Verification Tool${colors.reset}\n`);

    // Determine if input is URL or file
    const isUrl = input.startsWith('http://') || input.startsWith('https://');
    let content;
    let displayPath = input;

    if (isUrl) {
      info(`Downloading: ${input}`);
      content = await downloadFile(input);
      success('Downloaded successfully');
    } else {
      info(`Reading: ${input}`);
      content = fs.readFileSync(input, 'utf8');
      displayPath = path.resolve(input);
      success('File read successfully');
    }

    // Parse dossier
    info('Parsing dossier...');
    const { frontmatter, body } = parseDossier(content);
    success(`Parsed: ${frontmatter.title} v${frontmatter.version}`);

    if (options.verbose) {
      console.log(`\n${colors.bright}Dossier Metadata:${colors.reset}`);
      console.log(`  Title: ${frontmatter.title}`);
      console.log(`  Version: ${frontmatter.version}`);
      console.log(`  Risk Level: ${frontmatter.risk_level}`);
      console.log(`  Protocol: ${frontmatter.protocol_version}`);
    }

    // Verify checksum
    console.log(`\n${colors.bright}üìä Integrity Check:${colors.reset}`);
    const checksumResult = verifyChecksum(body, frontmatter.checksum?.hash);

    if (checksumResult.passed) {
      success('Checksum VALID - content has not been tampered with');
      if (options.verbose) {
        console.log(`   Hash: ${checksumResult.actual}`);
      }
    } else {
      error('Checksum INVALID - content has been modified!');
      if (options.verbose) {
        console.log(`   Declared: ${checksumResult.declared}`);
        console.log(`   Actual:   ${checksumResult.actual}`);
      }
    }

    // Verify signature
    console.log(`\n${colors.bright}üîè Authenticity Check:${colors.reset}`);
    const signatureResult = await verifySignature(body, frontmatter);

    if (signatureResult.present) {
      if (signatureResult.verified && signatureResult.trusted) {
        success('Signature VERIFIED - from trusted author');
      } else {
        warning(signatureResult.message);
        if (frontmatter.signature?.signed_by) {
          console.log(`   Signed by: ${frontmatter.signature.signed_by}`);
        }
      }
    } else {
      warning('No signature present (dossier is unsigned)');
    }

    // Assess risk
    console.log(`\n${colors.bright}üî¥ Risk Assessment:${colors.reset}`);
    const risk = assessRisk(frontmatter, checksumResult, signatureResult);

    const riskColors = {
      low: 'green',
      medium: 'yellow',
      high: 'yellow',
      critical: 'red',
    };

    log(`   Risk Level: ${risk.level.toUpperCase()}`, riskColors[risk.level]);

    if (risk.issues.length > 0) {
      console.log(`\n   Issues Found:`);
      risk.issues.forEach(issue => {
        console.log(`   - ${issue}`);
      });
    }

    // Recommendation
    console.log(`\n${colors.bright}Recommendation:${colors.reset}`, risk.recommendation);

    if (risk.recommendation === 'BLOCK') {
      error('\nDO NOT EXECUTE this dossier');
      console.log('   Security verification failed.');
      console.log('   This dossier may have been tampered with or is from an untrusted source.\n');
      return false;
    } else if (risk.level === 'medium' || risk.level === 'high') {
      warning('\nProceed with CAUTION');
      console.log('   Review the dossier code before executing.');
      console.log('   Consider the risk level and your trust in the source.\n');
      return true;
    } else {
      success('\nSafe to execute');
      console.log('   Dossier passed security verification.\n');
      return true;
    }

  } catch (err) {
    error(`\nVerification failed: ${err.message}`);
    if (options.verbose) {
      console.error(err);
    }
    return false;
  }
}

// Main entry point
async function main() {
  const options = parseArgs();

  if (options.help || !options.input) {
    showHelp();
    process.exit(options.help ? 0 : 2);
  }

  const passed = await verifyDossier(options.input, options);

  if (!passed) {
    process.exit(1);  // Verification failed
  }

  if (options.run) {
    warning('\n--run flag not yet implemented');
    warning('For now, manually execute the dossier if verification passed');
  }

  if (options.outputPath) {
    // Would output the path to downloaded file
    warning('\n--output-path flag not yet implemented');
  }

  process.exit(0);  // Success
}

// Run if called directly
if (require.main === module) {
  main().catch(err => {
    error(`Fatal error: ${err.message}`);
    process.exit(2);
  });
}

module.exports = { verifyDossier, parseDossier, verifyChecksum };
